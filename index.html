<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Présentation - Emilie Anglade</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h4>Titre professionnel développeuse web et web mobile</h4>
					<p style="color: #ac109f">Emilie Anglade</p>
				</section>
				<section data-auto-animate>
					<img width="350" src="img/logo_gris.png"> 
					<p>1. Développer la partie back-end d'une application web</p>
					<img width="300" src="img/logo-edtake.png"> 
					<p>2. Développer la partie front-end d'une application web</p>
				</section>
				<section data-auto-animate>
					<img width="350" src="img/logo_gris.png">
					<p>Accélérateur de croissance pour les startups et les PME</p>
					<aside class="notes">
						projet client école
						prototype application web ‘Rankscoring’ commandité par Frédéric Goldzak de Networklink.
						un accélérateur de croissance pour les startups et PME et service d'ingénierie opérationnelle
					</aside>
				</section>
				<section data-auto-animate>
					<h4>Le projet : développer un outil de rating/scoring</h4>
				</section>
				<section data-auto-animate>
					<h4 style="margin-bottom: 50px;">Le projet : développer un outil de rating/scoring</h4>
					<ul>
						<li>Permettre aux startups d'évaluer leur degré de maturité</li>
						<li class="fragment">Le livrable pour la startup est un Scoring et un Executive Summary.
						</li>
						<li class="fragment">Permettre aux investisseurs de pouvoir se décider sur un one pager et une notation
						</li>
					</ul>
					<aside class="notes">
						Produit a destination des startups pour évaluer leur maturité avant de prétendre à une levée de fonds
						2 questionnaires pour la start-up: général et scoring: 5 familles d'indicateurs / 9 questions par famille / 5 choix de réponses par question
					</aside>
				</section>
				<section>
					<h3 style="color: #ac109f">Outils utilisés</h3>
					<img src="img/nodejs-new-pantone-black.svg" width="250">
					<img src="img/express-facebook-share.png" width="250">
					<img src="img/mysql_workbench.jpg" width="250">
				</section>
				<section>
					<h3 style="color: #ac109f">Réalisations : </h3>
					<ul>
						<li>
							Création de la base de données
						</li>
						<li>
							Poster les réponses du questionnaire 'Général' dans la base de données
						</li>
						<!-- <li>
							Récupérer le scoring d'une start-up
						</li> -->
						<li>
							Récupérer toutes les données relatives à une start-up afin d'établir son executive summary
						</li>
					</ul>
				</section>
				<section>
					<p style="color: #ac109f">Création de la base de données</p>
					<ul>
						<li>
							<p style="font-size:2rem; text-align: start;">2 questionnaires: </p>
							<ul>
								<li>
									<p style="font-size:2rem; text-align: start;">Question : texte, ordre d'apparition, famille, type</p>
								</li>
								<li>
									<p style="font-size:2rem; text-align: start;">Réponse : texte, valeur</p>
								</li>
							</ul>
						</li>
						<li>
							<p style="font-size:2rem; text-align: start;">Start-up:</p>
							<ul>
								<li>
									<p style="font-size:2rem; text-align: start;">Profil</p>
								</li>
								<li>
									<p style="font-size:2rem; text-align: start;">Scoring</p>
								</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Données nécessaires création scoring executive summary : 
						2 questionnaires composés chacun de plusieurs questions,
						Pour une question: un énoncé, un ordre d’apparition, une famille et un type: ouverte ou fermée avec un choix de réponses:
						Pour une réponse:  un texte et une valeur (exemple: de 1 à 5 pour le scoring).
						En ce qui concerne la startup, elle s’identifie avec un mail et un mot de passe.
						Après avoir répondu aux deux questionnaires, elle doit pouvoir consulter les résultats de son scoring et générer un executive summary à partir de ses informations de profil.
					</aside>
				</section>
				<section>
					<img class="r-stretch" src="img/db100.png">
				</section>
				<section>
					<p style="font-size:2rem; text-align: start; color: #ac109f">Poster les réponses du questionnaire 'Général' dans la base de données</p>
					<pre style="font-size: 0.95rem;">
						<code style="max-height: 500px;" data-trim data-line-numbers="7-11 | 13-24" data-noescape>
							const express = require("express");
							const connection = require("../db");
							const router = express.Router();
							
							router.post("/general", async (req, res) => {
							try {
								const { generalForm, startupId } = req.body;
								const { activityArea } = req.body.generalForm;
								const { startupPosition } = req.body.generalForm;
								delete generalForm.activityArea;
								delete generalForm.startupPosition;

								const startupProfileQuery = `INSERT INTO startup_profile SET ? ON DUPLICATE KEY UPDATE ?`;
								const generalFormValues = { ...generalForm, startup_id: startupId }
								await connection.query(startupProfileQuery, [generalFormValues, generalFormValues]);
							
								const activityAreaQuery = `INSERT INTO activity_area SET ? ON DUPLICATE KEY UPDATE ?;`;
								const activityAreaValues = { startup_id: startupId, ...activityArea };
								await connection.query(activityAreaQuery, [activityAreaValues, activityAreaValues]);
							
								const positionQuery = `INSERT INTO position SET ? ON DUPLICATE KEY UPDATE ?;`;
								const positionValues = { startup_id: startupId, ...startupPosition };
								await connection.query(positionQuery, [positionValues, positionValues]);

								res.sendStatus(200);
							} catch (error) {
								res.status(500).send(error);
							}
							});
							module.exports = router;

						</code>
					</pre>
					<aside class="notes">
						Les réponses renvoyées par le questionnaire de profil sont stockées dans 3 tables différentes: startup_profile, position, activity_area.
						Nous devons donc en premier lieu séparer les données reçues: 
						+ Puis pour chaque table, envoyer les données correspondantes
						La syntaxe INSERT INTO … SET est propre à MySQL et équivalente au standard SQL:  INSERT INTO … VALUES
						L’instruction ON DUPLICATE KEY UPDATE est une fonctionnalité de MySQL qui permet de mettre à jour les données si un enregistrement existe déjà dans la table.
					</aside>
				</section>
				<!-- <section data-auto-animate>
					<p style="font-size:2rem; text-align: start; color: #ac109f">Récupérer le scoring d'une start-up</p>
					<div class="r-stack">
						<img width="800" src="img/rankscoring_scoring_result.png">
						<img class="fragment" width="800" src="img/postman-get-scoring.PNG">
					</div>
					<aside class="notes">
						Après avoir répondu au questionnaire, le résultat de chaque famille du scoring de la start-up est stocké dans la table scoring.
					</aside>
				</section>
				<section data-auto-animate>
					<p style="font-size:2rem; text-align: start; color: #ac109f">Récupérer le scoring d'une start-up</p>
					<pre>
						<code data-trim data-line-numbers data-noescape>
							const express = require("express");
							const connection = require("../db");
							
							const router = express.Router();
							
							router.get("/:idStartup/scoring", async (req, res) => {
								try {
									const { idStartup } = req.params;
									const [scoring] = await connection.query(
									`SELECT * FROM scoring WHERE startup_id = ? ;`,
									[idStartup]
									);
									res.status(200).json(scoring);
								} catch (err) {
									console.error(err);
									res.status(500).send("A problem occured fetching startup profile");
								}
							});
						</code>
					</pre>
				</section> -->
				<section data-auto-animate>
					<p style="font-size:2rem; text-align: start; color: #ac109f">Récupérer toutes les données relatives à une start-up afin d'établir son executive summary</p>
					<p style="font-size:2rem; text-align: start;">Données réparties sur 3 tables :</p>
					<ul>
						<li>
							<p style="font-size:2rem; text-align: start;">‘startup_profile’</p>
						</li>
						<li>
							<p style="font-size:2rem; text-align: start;">‘activity_area’</p>
						</li>
						<li>
							<p style="font-size:2rem; text-align: start;">‘position’</p>
						</li>
					</ul>
					<aside class="notes">
						Afin d’établir un executive summary, il est nécessaire de récupérer les informations de profil de la start-up concernée réparties sur 3 tables dans la base de données.
					</aside>
				</section>
				<section data-auto-animate>
					<p style="font-size:2rem; text-align: start; color: #ac109f">Récupérer toutes les données relatives à une start-up afin d'établir son executive summary</p>
				
					<pre>
						<code style="max-height: 500px;" data-trim data-line-numbers="17-55 | 45-49" data-noescape>
							router.get("/:idStartup/profile", async (req, res) => {
								try {
									const { idStartup } = req.params;
									const [
										profile,
									] = await connection.query(
										"SELECT * FROM startup_profile WHERE startup_id = ?;",
										[idStartup]
									);
									res.status(200).json(profile);
								} catch (err) {
									console.error(err);
									res.status(500).send("A problem occured fetching startup profile");
								}
							  });
							   
							  router.get("/:idStartup/activities", async (req, res) => {
								try {
									const { idStartup } = req.params;
									const [activities] = await connection.query(
										`SELECT * FROM activity_area WHERE startup_id = ?;`,
										[idStartup]
									);
									Object.keys(activities).forEach((key) => {
										if (activities[key] === 0) {
										delete activities[key];
										}
									});
									delete activities.startup_id;
									delete activities.id;
									res.status(200).json(activities);
								} catch (err) {
									console.error(err);
									res.status(500).send("A problem occured fetching startup activity");
								}
							  });
							   
							  router.get("/:idStartup/positions", async (req, res) => {
								try {
									const { idStartup } = req.params;
									const [positions] = await connection.query(
										`SELECT * FROM position WHERE startup_id = ?;`,
										[idStartup]
									);
									Object.keys(positions).forEach((key) => {
										if (positions[key] === 0) {
										delete positions[key];
										}
									});
									res.status(200).json(positions);
								} catch (err) {
									console.error(err);
									res.status(500).send("A problem occured fetching startup position");
								}
							  });
							  
						</code>
					</pre>
					<aside class="notes">	
						 + L’id de la startup concernée est passée en paramètre de l’URL, ses informations de profil sont récupérées dans la table ‘startup_profile’
	
						+ Les tables ‘position’ et ‘activity_area’ contiennent tous les positionnements et secteurs d’activité possibles pour une startup. 
						Chaque champ est associée à true ou false (0 ou 1 en SQL) selon si la startup a coché ou non la case dans le questionnaire (checkbox).
	
						+ Nous ne souhaitons pas renvoyer les champs dont la valeur est false (0), nous les supprimons donc si tel est le cas
					</aside>
				</section>
				<section>
					<img src="img/postman-get-activities.PNG">
				</section>
				<section>
					<h3 style="color: #ac109f">Conclusion</h3>
					<img src="img/logo_wcs.png" width="300" >
					<img style="margin: 30px;" width="400" src="img/logo_gris.png">
					<aside class="notes">
						Expérience trés enrichissante, dev fonctionnalités front en parrallele, pair programming 
					</aside>
				</section>
				<section data-auto-animate>
					<h4 style="color: #ac109f">Développer la partie front-end d'une application web</h3>
					<img class="fragment" src="img/logo-edtake.png">
					<aside class="notes">
						jeune start up 2019 , secteur edtech, équipe
					</aside>
				</section>
				<section data-auto-animate>
					<img src="img/logo-edtake.png">
					<p>Simplifier la conception des projets de formation à distance
					</p>
					<p class="fragment">Un logiciel dédié qui permet de répondre aux besoins de gestion et de production des utilisateurs
					</p>
					<aside class="notes">
						Objectif: simplifier la conception des projets de formation à distance tout en gardant une vue d’ensemble et en centralisant toutes les ressources nécessaires au développement de chaque projet (talents, livrables, modèles, plannings…)
						Solution: logiciel dédié autour de la logique saas enable marketplace
					</aside>
				</section>
				<section data-auto-animate>
					<h4>Le projet : développer un éditeur de storyboard</h4>
					<aside class="notes">
						a destination des freelances ingenieurs pedagogiques, auteurs, chefs de projet <br>
						maquetter des modules de formation, prévisualiser le texte, le visuel et les animations qui composent le module. 
						affiner le chiffrage du cout du module
					</aside>
				</section>
				<section data-auto-animate>
					<h4 style="margin-bottom: 50px;">Le projet : développer un éditeur de storyboard</h4>
					<p style="font-size:2rem; text-align: start;">Fonctionnalités attendues :</p>
					<ul>
						<li>créer un storyboard</li>
						<li class="fragment">créer une scène,</li>
						<li class="fragment">rédiger un script,</li>
						<li class="fragment">créer un visuel,</li>
						<li class="fragment">visualiser un résumé du storyboard</li>
						<li class="fragment">exporter les données vers Excel.</li>
					</ul>
					<aside class="notes">
						Fonctionnalités attendues:
						créer un storyboard et lui donner un titre,
						créer une scène, lui donner un titre, une description, rédiger son script
						créer un visuel par import d’images et/ou composition graphique,
						visualiser un résumé de son storyboard et de ses scènes,
						exporter les données vers Excel.
					</aside>
				</section>
				<section>
					<p style="font-size:2rem; text-align: start; margin-bottom: 60px; color:#ac109f">3 phases de développement</p>
					<table>
						<thead>
							<tr>
								<th class="fragment" data-fragment-index="1" align="center">R&D</th>
								<th class="fragment" data-fragment-index="2" align="center">V.0</th>
								<th class="fragment" data-fragment-index="3" align="center">MVP</th>
							</tr>
						</thead>
						<tbody style="font-size:1.6rem;">
							<tr>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="1">Structuration des données et des objets</td>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="2">Structuration du code</td>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="3">Refonte de l'expérience utilisateur</td>
							</tr>
							<tr>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="1">Modélisation du produit</td>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="2">Gestion de la mémoire</td>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="3">Génération d’une présentation dynamique</td>
							</tr>
							<tr>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="1">Recherche de librairies</td>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="2">Mise en place d’un système de state management</td>
								<td style="vertical-align: middle;" class="fragment" data-fragment-index="3">Génération d'un PDF exportable</td>
							</tr>
						</tbody>
					</table>
					<aside class="notes">
						R&D: apprentissage Vue.js Konva.js
						V0: apprentissage Vuex architecture du produit
						MVP: rédaction documentation avec l’équipe marketing,
						utilisation du framework reveal.js,
						jspdf 
					</aside>
				</section>
				<section>
					<h3 style="color: #ac109f">Mes réalisations</h3>
					<ul>
						<li>Développement d’un outil permettant de créer une composition graphique</li>
						<li>Architecture du produit</li>
						<li>Amélioration de l'expérience utilisateur</li>
					</ul>
				</section>
				<section data-auto-animate>
					<p style="font-size:3rem; text-align: center; color: #ac109f">Développement d’un outil permettant de créer une composition graphique</p>
					<aside class="notes">
						L’utilisateur a la possibilité de créer un visuel pour illustrer la scène.
						L’outil doit lui permettre d’ajouter diverses formes graphiques (rectangle, cercle, flèche bulles…), des images et du texte. 
						Puis de les déplacer, de modifier leur taille, leur inclinaison, leur couleur de remplissage, leur bordure, leur ordre d’apparition dans le plan et de les supprimer.
						Pour développer cet outil j’ai utilisé ‘Vue Konva’: une librairie Javascript permettant de créer des canvas complexes en utilisant Vue.js. en liaison avec le framework Konva.
					</aside>
				</section>
				<section data-auto-animate>
					<p style="font-size:2rem; text-align: center; color: #ac109f; margin-bottom: 70px;">Développement d’un outil permettant de créer une composition graphique</p>
					<p style="font-size:2rem; text-align: start;" class="fragment" data-fragment-index="1">Fonctionnalités attendues : </p>
					<ul style="font-size: 1.9rem; line-height: 2;">
						<li class="fragment" data-fragment-index="1">
							Ajout de diverses formes graphiques, 
						</li>
						<li class="fragment">
							Ajout d'images
						</li>
						<li class="fragment">
							Ajout de textes
						</li>
						<li class="fragment">
							Modification des caractéristiques de chaque élément 
						</li>
						<li class="fragment">
							Modification de l'ordre d'apparition de chaque élément
						</li>
					</ul>
				</section>
				<section data-auto-animate>
					<p style="font-size:2rem; text-align: center; color: #ac109f; margin-bottom: 70px;">Développement d’un outil permettant de créer une composition graphique</p>
					<p style="font-size:2rem; text-align: start;" >Problématiques : </p>
					<ul style="font-size: 1.9rem; line-height: 2;">
						<li class="fragment">
							<p>Placement et transformation d'éléments aux configurations différentes</p> 
						</li>
						<li class="fragment">
							<p>Emplacement de chaque élément dans la pile</p>
						</li>
						<li class="fragment">
							<p>Identification d'un élément au clic</p>
						</li>
					</ul>
				</section>
				<section data-auto-animate>
					<p style="text-align: center; font-size: 2rem; color: #ac109f;">Placement et transformation des éléments</p>
					<p style="text-align: start; font-size: 1.5rem;">Un composant générique 'V-Draw' : </p>
						<pre style="font-size: 0.95rem;">
							<code style="max-height: 500px;" class="hljs" data-trim data-line-numbers="1-11 | 44-48 | 14-33 | 40-50">
								<script type="text/template">
									components/CanvasEditor.vue
									<v-stage ref="stage" :config="configKonva" @mousedown="handleStageMouseDown">
										<v-layer>
											<VDraw
												v-for="item in shapesList"
												:key="item.config.name"
												:item="item"
											/>
											<v-transformer ref="transformer" />
										</v-layer>
									</v-stage>
									
									components/VDraw.vue
									<template>
										<v-rect
											v-if="item.type === 'rect'"
											:config="{
												...item.config,
												item.config.id
											}"
											@dragmove="handleDragMove"
											@transformend="handleTransformEnd"
											/>
										<v-circle
											v-if="item.type === 'circle'"
											:config="{
												...item.config,
												item.config.id
											}"
											@dragmove="handleDragMove"
											@transformend="handleTransformEnd"
										/>
									</template>
									<script>
										props: {
											item: {
												type: Object
											}
										},
										methods: {
											handleTransformEnd (e) {
												const config = e.target.attrs
												this.$store.dispatch('canvas/transformShape', config)
											},
											handleDragMove (e) {
												const x = e.target.attrs.x
												const y = e.target.attrs.y
												this.$store.dispatch('canvas/editShapePosition', {x, y})
											}
										}
									</script>
								</script>
							</code>
						</pre>
						<aside class="notes">
							Création composant générique V-Draw qui va gérer toute la mécanique de création et de placement de la shape en fonction de son type
							Les shapes sont stockées dans un tableau shapesList, 
							Une itération est faite sur ce tableau dans le composant V-draw 
							la shape est passée dans les props du composant 
							permet de restituer pour chaque forme le composant Konva attendue dans le layer.
						</aside>
				</section>
				<section data-auto-animate>
					<p style="text-align: center; font-size: 2rem; color: #ac109f;">Emplacement de chaque élément dans la pile</p>
					<p style="font-size: 2rem; ">Gérer l'ordre d'apparition dans le layer </p>
					<img src="img/codesandbox-order-shape.png">
					<aside class="notes">
						Emplacement ds pile fonction de son rang dans la liste affichée dans le layer
						1er élément restitué dans la layer sera au dernier plan sur la page
					</aside>
				</section>
				<section data-auto-animate>
					<p style="text-align: center; font-size: 2rem; color: #ac109f;">Emplacement de chaque élément dans la pile</p>
					<p style="text-align: start; font-size: 1.6rem;">Attribution d'un numéro d'ordre à chaque élément : </p>
					<pre>
						<code style="max-height: 500px;" class="hljs" data-trim data-line-numbers="14-18 | 23-38 | 24, 27 | 2, 7-13">
							<script type="text/template">
								export const state = () => ({
									shapesList: [],
									selectedShape: undefined
								})
								
								export const getters = {
									getShapes (state) {
										const shapes = [...state.shapesList]
										const res = shapes.sort((a, b) => {
											return a.order - b.order
										})
										return res
									},
									getNewOrder (state) {
									  	return state.shapesList.length > 0 
										? state.shapesList.map(e => e.order).reduce((a, b) => Math.max(a, b)) 
										: 0
									},
									...
								  }
								  
								  export const actions = {
									addArrowShape ({ commit, getters }) {
										const newOrder = getters.getNewOrder
										const newId = ObjectID().toHexString()
										const payload = { 
											order: newOrder + 1, 
											type: 'arrow', 
											config: { 
												id: newId, 
												name: `arrow_${newId}`, 
												x: 100, 
												y: 100, 
												points: [0, 0, 100, 0], 
												pointerLength: 15, 
												pointerWidth: 15, 
												...
											} 
										}
										commit('ADD_SHAPE', payload)
									},
									...
							</script>
						</code>
					</pre>
					<aside class="notes">
						Le numéro d'ordre est calculé avec le getter getNewOrder qui va restituer le numéro d'ordre
						le plus élevé de la liste des éléments puis attribué à l'élément à sa création
						La liste des éléments à afficher est récupérée dans le store grâce à un getter. 
						Pour etre sure que l'ordre de chaque scène est respecté j'applique la méthode sort 
						qui va trié la liste selon le numéro d'ordre de chaque élément
						C'est avec ce numéro d'ordre que j'ai pu gérer une autre fonctionnalité à savoir permettre au user de reculer / avancer d'un plan un élément
					</aside>
				</section>
				<section data-auto-animate>
					<p style="text-align: center; font-size: 2rem; color: #ac109f;">Identification d'un élément au clic</p>
					<p style="text-align: start; font-size: 1.9rem;">Enjeux : </p>
					<ul  style="font-size: 1.9rem; line-height: 2;">
						<li>
							Rattacher le 'v-transformer' à l'élément sélectionné 
						</li>
						<li>
							Mettre à jour la 'toolbar' en fonction de l'élément sélectionné
						</li>
					</ul>
				</section>
				
				<section>
					<p style="text-align: center; font-size: 2rem; color: #ac109f;">Identification d'un élément au clic</p>
					<p style="text-align: start; font-size: 1.6rem;">Déclenchement d'une fonction d'identification à chaque clic dans le stage @mouseDown="handleStageMouseDown"</p>
					<pre>
						<code style="max-height: 500px;" class="hljs" data-trim data-line-numbers="3-9 | 11-24 | 28 | 31-45 ">
							<script type="text/template">
								handleStageMouseDown (e) {
									// clicked on stage - clear selection
									if (e.target === e.target.getStage()) {
										this.editText = false
										this.editShapeColor = false
										this.editSelectedShape(undefined)
										this.updateTransformer()
										return
								  	}
								  	// find clicked shape by its id
									const { shapeId } = e.target.attrs
									const shape = this.shapesList.find(s => s.config.id === shapeId)
									if (shape) {
										this.editSelectedShape({ shapeId, config: shape.config })
										if (shape.type !== 'text' && shape.type !== 'image') {
											this.editText = false
											this.editShapeColor = true
										} else if (shape.type === 'text') {
											this.editShapeColor = false
											this.editText = true
										} else if (shape.type === 'image') {
											this.editShapeColor = false
											this.editText = false
										}
									} else {
										this.editSelectedShape(undefined)
									}
									this.updateTransformer()
								},

								updateTransformer () {
									// here we need to manually attach or detach Transformer node
									const transformerNode = this.$refs.transformer.getNode()
									const stage = transformerNode.getStage()
									const selectedNode = stage.findOne('#' + this.selectedShape.shapeId)
									if (selectedNode === transformerNode.node()) {
										return  // do nothing if selected node is already attached
									}
									if (selectedNode) {    // attach to another node
										transformerNode.nodes([selectedNode])
									} else {    // remove transformer
										transformerNode.nodes([])
									}
									transformerNode.getLayer().batchDraw()
								}								
							</script>
						</code>
					</pre>
					<aside class="notes">
						Création d'une fonction d'identification qui est appelée à chaque clic de l'user dans le stage 
						Elle va vérifier si la cible du clic est le stage ou une shape. 
						Si la cible du clic est le stage, le state local est alors réinitialisé, si une shape était sélectionné elle est déselctionnée.
						 + Si la cible du clic est une shape: 
						le state local est actualisé en fonction de son type. et permet ainsi l'actualisation de la Toolbar qui est branché sur le ce meme state 
						+ le transformer est déclenché 
						+ transformer rattaché à la shape sélectionnée grace à son id 
					</aside>
				</section>
				<section data-auto-animate>
					<p style="font-size:3rem; text-align: center; color: #ac109f; margin-bottom: 70px;">Architecture du composant</p>
				</section>
				<section data-auto-animate>
					<p style="font-size:3rem; text-align: center; color: #ac109f; margin-bottom: 70px;">Architecture du composant</p>
					<p style="font-size:2rem; text-align: start;"  class="fragment" data-fragment-index="1">Problématique : </p>
					<ul style="font-size: 1.9rem; line-height: 2;">
						<li class="fragment" data-fragment-index="1">
							<p>Créer un produit modulaire intégrable dans une application</p>
							<ul class="fragment">
								<li>Gestion autonome des états et de la mise à jour des données du composant</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<p style="font-size:3rem; text-align: center; color: #ac109f; margin-bottom: 70px;">Architecture du composant</p>
					<ul style="font-size: 1.9rem; line-height: 2;">
						<li>
							Un composant parent 'Storyboard'
						</li>
						<li>
							Un système de state management : store Vuex
						</li>
					</ul>
					<img src="img/architecture.png" class="r-stretch">
				</section>
				<section>
					<h3 style="color: #ac109f">Et maintenant ...</h3>
				</section>
			</div>
		</div>

<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
